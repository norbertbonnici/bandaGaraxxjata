{"name":"Banda Garaxxjata","body":"￼University of Malta Course Unit: _CIS2051_\r\n\r\nby Norbert Bonnici _&_ [Malcolm Debono](http://malcolmdebono.com)\r\n\r\n￼￼Academic Year: 2011/2012\r\n\r\n# Contents\r\n1. Specification of Work\r\n\r\n2. Design\r\n\r\n3. Implementation\r\n\r\n4. Evaluation\r\n\r\n5. Screenshots\r\n\r\n# Specification of Work\r\n\r\n## Classes\r\n**Program** Displays the MusicKeyboard form\r\n\r\n**MusicKey** Creates a new music key (object) with the specified note id and at a specified location (x,y)\r\n\r\n**BlackMusicKey** A sub-class of MusicKey used to create a black music key MusicKeyboard Form which shows the music keyboard by generating music keys and contains many methods and events related to a music keyboard\r\n\r\n**Noti** Takes care of drawing notes through a PaintEventArgs object and performs note manipulation\r\n\r\n**Stave** Form which shows the stave by generating an array of 36 notes and uses the Noti class to manipulate them\r\n\r\n## Events\r\n**MusicKeyboard_Load** Generates the music keys at runtime\r\n\r\n**dummyKey_MouseDown** Plays the sound of the relevant note according to the key pressed, shows which key was pressed (both the id of the key in the textbox as well as highlights the physical key by changing the image of the key), stores the ID of the key pressed if recording is checked, and passes the ID of the key pressed to the stave\r\n\r\n**dummyKey_MouseUp** Resets the image of the key back to the default state ￼\r\n\r\n**playback_Tick** Handles playback by playing the recorded notes one by one until all of them are played, and displays the playback status graphically using a progress bar\r\n\r\n**bPlay_Click** Plays back the recorded song at the tempo specified by the user bStop Click Stops playback of the recorded song\r\n\r\n**bDelete_Click** Clears the recording list to start a new song\r\n\r\n**bSpace_Click** Inserts a gap into the recording\r\n\r\n**cbRecord_CheckedChanged** Updates the record button to reflect recording state according to whether it is checked or not\r\n\r\n**cbLoop_CheckedChanged** Updates the loop button to reflect whether loop mode is turned on or off according to whether it is checked or not\r\n\r\n**cbStave_CheckedChanged** Shows or hides the stave window\r\n\r\n**Stave_Paint** Draws the stave lines, and an array of 36 notes and accidentals\r\n\r\n**Stave_MouseDown** Calls an appropiate function (depends on which mouse but- ton was used) to modify a note\r\n\r\n**Stave_FormClosing** Hides the stave when the close button is pressed btUpload Click Sends data from the stave to the MusicKeyboard object btClear Click Clears all notes from the stave\r\n\r\n￼￼￼￼￼￼￼￼￼￼￼￼￼\r\n# Design\r\n\r\n## Class Hierarchy\r\n\r\nA high level class hierarchy of all the classes within the application:\r\n\r\n## Design Issues\r\n\r\n1. Since the keys are generated at runtime, the user can see the keys being drawn sequentially.\r\n\r\n￼\r\n# Implementation\r\n\r\n## Listing of Methods\r\n\r\n### MusicKey \r\n_MusicKey(int iNote, int x, int y)_\r\n\r\n### BlackMusicKey \r\n_BlackMusicKey(int iNote, int x, int y)_\r\n\r\n### MusicKeyboard \r\n_MusicKeyboard()_\r\n\r\n_void MusicKeyboard Load(object sender, EventArgs e)_\r\n\r\n_void dummyKey MouseDown(object sender, MouseEventArgs e)_\r\n\r\n_void dummyKey MouseUp(object sender, MouseEventArgs e)_\r\n\r\n_void enablePlayback()_\r\n\r\n_void disablePlayback()_\r\n\r\n_void playKey(int id)_\r\n\r\n_void bPlay Click(object sender, EventArgs e)_\r\n\r\n_void playback Tick(object sender, EventArgs e)_\r\n\r\n_void bDelete Click(object sender, EventArgs e)_\r\n\r\n_void bStop Click(object sender, EventArgs e)_\r\n\r\n_void bSpace Click (object sender, EventArgs e)_\r\n\r\n_void cbRecord CheckedChanged(object sender, EventArgs e)_\r\n\r\n_void highlightKey(int prev, int current)_\r\n\r\n_void cbLoop CheckedChanged(object sender, EventArgs e)_\r\n\r\n_void cbStave CheckedChanged(object sender, EventArgs e)_\r\n\r\n_override bool ProcessCmdKey(ref Message msg, Keys keyData)_\r\n￼￼￼￼￼￼￼￼￼￼￼\r\n### ￼Noti\r\n_public void drawNote(PaintEventArgs hagu, int id, int x, int y, string acc, string mod)_\r\n\r\n_public void drawNote(PaintEventArgs hagu)_\r\n\r\n_private void pingiNota(PaintEventArgs picasso, int id, int x, int y, string acc, string mod)_\r\n\r\n_private void pingiCleff(PaintEventArgs picasso)_\r\n\r\n_private int noteToInt(int nota)_\r\n\r\n_public int yToPitch(int y, string acc)_\r\n\r\n_public int msToDuration(int ms)_\r\n\r\n_public int pitchToY(int pitch)_\r\n\r\n_private int locationToX(int x)_\r\n\r\n_public void changeNote(int x, int y)_\r\n\r\n_public void changeNote(int i, int pitch, int duration, string acc)_\r\n\r\n_public void changeNote(int x)_\r\n\r\n_public void changeNote(int x, bool acc)_\r\n\r\n_private void zidJewMexxiNota(int x, int y)_\r\n\r\n_private void zidNota(int identita, int pitch, int ms, string acc)_\r\n\r\n_private void ibdelTulTaNota(int x)_\r\n\r\n_private void ibdelAccTaNota(int x, bool acc)_\r\n\r\n_public Stave(MusicKeyboard mk)_\r\n\r\n_private void Stave Paint(object sender, PaintEventArgs picasso)_\r\n\r\n_private void Stave MouseDown(object sender, MouseEventArgs gur- dien)_\r\n\r\n_private void btUpload Click(object sender, EventArgs e)_\r\n\r\n_private void btClear Click(object sender, EventArgs e)_\r\n\r\n_public void addNoteFromKeyboard(int pitch, long ms)_\r\n\r\n_private void Stave FormClosing(object sender, FormClosingEventArgs e)_\r\n\r\n## Core Methods in detail\r\n\r\n### void MusicKeyboard_Load(object sender, EventArgs e)\r\n1. Uses two for-loops to construct the piano keys, and at each stage increments both the ID of the note and the X position\r\n1. Two for-loops are used (instead of one) as the white and black keys are created separately. This makes it easier to assign their location as well as their ID\r\n1. Adds a MouseDown and MouseUp event handler to each key\r\n\r\n### void dummyKey_MouseDown(object sender, MouseEventArgs e)\r\n1. Checks which key was pressed by comparing all MusicKeys to the sender.\r\n1. Outputs the ID of the key pressed to the textbox\r\n1. Changes the image of the key pressed to highlight it. The **GetType()** method is used to determine if the key is black or white.\r\n1. If the recording checkbox is checked, the note pressed is added to the recording list and a stopwatch (used to measure the duration of the key) is started.\r\n\r\n### void dummyKey_MouseUp(object sender, MouseEventArgs e)\r\n1. Checks which key was pressed by comparing all MusicKeys to the sender.\r\n1. Used to change the image of the key pressed to the default state as soon as it is released.\r\n1. The **GetType()** method is used to determine if the key is black or white in a simple for-loop by converting the type to string and checking if it contains the text _BlackMusicKey_.\r\n1. Stops the stopwatch, and passes both the key ID and the duration to the stave.\r\n\r\n### void playKey(int id)\r\n1. The sound file of the player is changed according to the integer passed.\r\n1. The sound file is played.\r\n\r\n### void bPlay_Click(object sender, EventArgs e)\r\n1. Converts the BPM entered by the user to milliseconds.\r\n1. Sets the interval of the playback timer to the converted milliseconds value, so that the BPM determines the interval between each key.\r\n1. Starts the playback timer.\r\n1. Updates UI to reflect playback, including changing the image of the play button and enabling the stop button.\r\n\r\n### void playback_Tick(object sender, EventArgs e)\r\n1. Integer playCount is used as a counter to keep track of how many notes where played\r\n1. The integer is compared to the total number of notes stored in the recording list _recording.Count_\r\n1. If the integer is smaller, the key in the recording list at the playCount position is played if it is not equal to -1 (which indicates that there is a space), and playCount is incremented by 1. The progress bar is also updated by dividing the playCount by the total number of notes stored in the recording list _recording.Count_, and multiplying the result by 100 to get a percentage. The current key is also highlighted by calling the highlightKey method, and unless it is the first note played, the previous note is returned to the normal state.\r\n1. Otherwise, if the loop checkbox is checked, playback is restarted by resetting the playCount counter and playing the first note (this is done here so as to avoid having a gap when the song ends which results from the timer having to wait for another tick). If the loop checkbox is unchecked, the playback timer is stopped and the user is informed that the song ended.\r\n\r\n### void highlightKey(int prev, int current)\r\n1. A temporary **MusicKey()** called _mk_ is created\r\n1. A value of _-1_ in the prev variable indicates that there wasn't a previous key, i.e. the key played was the first one. Therefore if the value of this integer is not equal to _-1_, _mk_ is set to the previous key, and it's image is changed back to normal state, depending on whether it is a black or white key (using the **GetType()** method to determine the key type)\r\n1. _mk_ is then set to the current key, and it's image is changed to the highlighted (or down) state, again depending on whether it is a black or white key\r\n\r\n### void pingiNota(PaintEventArgs picasso, int id, int x, int y, string acc, string mod)\r\n1. Two bitmap objects _mappa_ and _sharp_ are created to hold images for the note and accidentals.\r\n1. Since the accidental is not using an alpha in the image, a function **MakeTransperent()** was used to create a transparency from the background.\r\n1. The PaintEventArgs object is used to draw the bitmap objects with the coordinates which were passed as parameters, and with the bitmap object's own dimensions. \r\n\r\n### int noteToInt(int nota)\r\n1. Converts a y coordinate to a note position on the stave (y-axis)\r\n1. Creates a temporary variable, _position_ and sets it to _-1_\r\n1. Starts a for-loop from grobal variables _min_ till _(interval * 7) + min_ with increments of _interval_\r\n1. If _nota_ is one more or one less than the current position, the variable _position_ is set to the current position minus 28, which means that the note is on a line of the stave\r\n1. If the current position is not equal to ((_interval_ * 7) + _min_) and if _nota_ is between (2 + current position) and (current position + global variable _interval_ + 2), the variable _position_ is set to the current position minus 20, which means that the note is on the space between lines on the stave\r\n1. The variable _position_ is returned\r\n\r\n### int yToPitch(int y, string acc)\r\n1. Converts a y coordinate to a wave ID (_pitch_)\r\n1. Creates a temporary variable _pitch_ and sets it to zero, and an array of integers and fills it with possible wave IDs of natural notes\r\n1. The same for-loop from the method above is used but encapsulated in an if statement to check the validity of the y coordinate\r\n1. If the position is on a line on the stave the variable _pitch_ is set to the integer in the array with position (2 * ((current position - _min_) / 15))\r\n1. Else if the position is between a line _pitch_ is set to the integer in the array with position ((2 * ((current position - min) / 15)) + 1)\r\n1. If the string _acc_ is \"#\" and if _pitch_ is not _25_, _pitch_ is increased by _1_\r\n1. The variable _pitch_ is returned.\r\n\r\n### int pitchToY(int pitch)\r\n1. Converts wave IDs to y coordinates to be used on the stave\r\n1. Creates a temporary variable _index_ and sets it to _-1_, and an array of integers and fills it with possible wave IDs of natural notes\r\n1. Loops through the the array and checks if _pitch_ is equal to one of the integers in the array and if it is true _index_ is set to that integer\r\n1. If _index_ is still _-1_ the array is looped through and check for an integer between two positions and returns the current position + 1 which would be the index of an accidental\r\n1. If _pitch_ is valid, a for-loop from global variables _min_ till _(interval * 7) + min_ with increments of _interval_ is started.\r\n1. If _index_ is equal to (2 * ((current position - _min_) / 15)), the current position - 28 is returned (on a line)\r\n1. Else if _index_ is equal to the previous limit + 1, the current position - 20 is returned (in a space)\r\n1. Else 0 is returned (just in case)\r\n\r\n### int msToDuration(int ms)\r\n1. Converts milliseconds to an integer duration notation currently used to show different note durations\r\n1. If _ms_ is _0_, _0_ is returned, else if _ms_ is between the classical note durations, an integer from _1_ to _5_ is returned, depending on the duration\r\n\r\n### int locationToX(int x)\r\n1. Converts x coordinates to possible locations on the x axis on the stave\r\n1. Creates a temporary variable _position_ and sets it to _-1_\r\n1. Starts a for-loop from 110 (initial position) to 820 (final position) with increments of 20 (spacing between notes)\r\n1. If _x_ is between the current position ±9, _position_ is set to the current position minus 110 and divided by _20_\r\n1. _position_ is returned\r\n\r\n### void ibdelTulTaNota(int x)\r\n1. Changes the duration of a note.\r\n1. Creates a temporary variable _identita_ from the method **locationToX(_x_)**\r\n1. If _identita_ is valid and if the duration of the note in position _identita_ is _5_ the duration is set to _0_ (rest) else the duration is incremented.\r\n\r\n### void ibdelAccTaNota(int x, bool acc)\r\n1. Changes the accidental of a note.\r\n1. Creates a temporary variable _identita_ from the method **locationToX(_x_})**\r\n1. If _identita_ is valid the accidental of the note in position _identita_ is \"#\" the accidental is set to \"blank\" (natural) and the pitch is reduced by 1 else the accidental is set to \"#\" (sharp) and the pitch is increased by 1 \r\n\r\n### void zidJewMexxiNota(int x, int y)\r\n1. Creates or moves a note to a new y coordinate\r\n1. Creates a temporary variable _identita_ from the method **locationToX(_x_)**\r\n1. Creates a temporary variable __y_ from the method **noteToInt(_y_)**\r\n1. If __y_ and _identita_ are valid then the y coordinate of the note at position _identita_ is set to __y_ and the pitch is set to the value the method **yToPitch()** returns\r\n1. If there is no note in that position it is set to 3 (a crotchet) as it is the most commonly used duration\r\n1. If __y_ is smaller or equal to _45_ the image is set to the inverted one using the mod parameter in the note and increasing the y coordinate value of the note by 21, else the mod parameter is set to null.\r\n\r\n### void zidNota(int identita, int pitch, int ms, string acc)\r\n1. Creates a note with data from **MusicKeyboard()**\r\n1. Creates a temporary variable __y_ from the method **pitchToY(_y_)**\r\n1. If _pitch_ and _identita_ are valid then the y coordinate of the note at position _identita_ is set to __y_ and pitch is set to _pitch_\r\n1. The duration of the note is set using the method **msToDuration(ms)**\r\n1. If __y_ is smaller or equal to _45_ the image is set to the inverted one using the mod parameter in the note and increasing the y coordinate value of the note by 21, else the mod parameter is set to null.\r\n\r\n\r\n# Evaluation\r\n\r\n## Features of Current Program\r\n\r\n### General\r\n– Play notes by pressing the keys on the music keyboard\r\n\r\n– The ID of the key pressed is displayed\r\n\r\n– The visibility of the stave window can be toggled to take up less screen space\r\n\r\n– Keyboard shortcuts \r\n\r\n### Recording\r\n– Keys are only recorded when the ’Record keys’ checkbox is checked\r\n\r\n– This means that the user can easily record a song in several parts (for example recording part of the song, hearing it, and continue recording, or even unchecking the recording box to compare different notes to record next)\r\n\r\n– A gap can also be inserted at the current position with the press of a button, to separate notes from each other. Multiple gaps can also be inserted to increase the duration between the notes.\r\n\r\n– Due to the nature of the program, recordings of the stave and the keyboard are handled separately. We opted for such an implementation since this gives the user the ability to add notes from the stave multiple times. Clearing the stave doesn’t clear the recording.\r\n\r\n### Playback\r\n– Recording is played from beginning when user clicks the Play button\r\n\r\n￼– Playback can be stopped at any time by pressing the Stop button\r\n\r\n– User can set a custom tempo in BPM (default is set to 120) to make the song play faster or slower\r\n\r\n– The song can also be played in loop mode, so that it is played continu- ously until the user stops it\r\n\r\n– The user is also given visual indication of the playback via the progress bar at the bottom of the application\r\n\r\n### Stave\r\n– The user can add or move a note by clicking with the left mouse button in a space on the stave\r\n\r\n– The ability to change the accidental of a note by clicking with the middle mouse button on the stave\r\n\r\n– Changing the duration of a note by clicking with the right mouse button on the stave\r\n\r\n– Exporting notes to the music keyboard to be played\r\n\r\n### Installation\r\n– InstallShield was used to package the application to a single executable to be installed on any Windows machine\r\n\r\n– Icons were made and implemented in the application\r\n\r\n## Suggestions and Improvements\r\n1. Optimize performance (better handling of images and sound files)\r\n\r\n2. Better handling of sound files (the built-in library is limited)\r\n\r\n3. One feature that we could have added if we had more time is to save and load the recordings\r\n\r\n4. Another feature which we could have added is to export the stave with notes as an image\r\n\r\n5. Ledger lines could have been added for when notes are out of the stave lines\r\n\r\n# Screenshots\r\n￼Figure 5.1: The program upon starting\r\n\r\n￼￼Figure 5.2: Keyboard to stave input\r\n\r\n￼￼Figure 5.3: A sample score by Beethoven (Ode to joy)","tagline":"A simple music editor","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}